require("dotenv").config();
const {
  Client,
  GatewayIntentBits,
  PermissionsBitField,
  REST,
  Routes,
  SlashCommandBuilder,
  EmbedBuilder,
  ChannelType
} = require("discord.js");
const mongoose = require("mongoose");

/* =============================
   DATABASE SETUP
============================= */

mongoose.connect(process.env.MONGO_URI)
  .then(() => console.log("âœ… MongoDB Connected"))
  .catch(console.error);

const warnSchema = new mongoose.Schema({
  guildId: String,
  userId: String,
  warnings: [{
    reason: String,
    moderator: String,
    date: { type: Date, default: Date.now }
  }]
});

const economySchema = new mongoose.Schema({
  guildId: String,
  userId: String,
  balance: { type: Number, default: 0 }
});

const levelSchema = new mongoose.Schema({
  guildId: String,
  userId: String,
  xp: { type: Number, default: 0 },
  level: { type: Number, default: 0 }
});

const Warn = mongoose.model("Warn", warnSchema);
const Economy = mongoose.model("Economy", economySchema);
const Level = mongoose.model("Level", levelSchema);

/* =============================
   CLIENT SETUP
============================= */

const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.GuildMembers,
    GatewayIntentBits.MessageContent
  ]
});

/* =============================
   SLASH COMMANDS
============================= */

const commands = [
  new SlashCommandBuilder().setName("ping").setDescription("Bot ping"),

  new SlashCommandBuilder()
    .setName("ban")
    .setDescription("Ban user")
    .addUserOption(o => o.setName("user").setDescription("User").setRequired(true)),

  new SlashCommandBuilder()
    .setName("kick")
    .setDescription("Kick user")
    .addUserOption(o => o.setName("user").setDescription("User").setRequired(true)),

  new SlashCommandBuilder()
    .setName("timeout")
    .setDescription("Timeout user")
    .addUserOption(o => o.setName("user").setDescription("User").setRequired(true))
    .addIntegerOption(o => o.setName("minutes").setDescription("Minutes").setRequired(true)),

  new SlashCommandBuilder()
    .setName("warn")
    .setDescription("Warn user")
    .addUserOption(o => o.setName("user").setDescription("User").setRequired(true))
    .addStringOption(o => o.setName("reason").setDescription("Reason").setRequired(true)),

  new SlashCommandBuilder()
    .setName("warnings")
    .setDescription("Check warnings")
    .addUserOption(o => o.setName("user").setDescription("User").setRequired(true)),

  new SlashCommandBuilder().setName("work").setDescription("Earn money"),

  new SlashCommandBuilder().setName("balance").setDescription("Check balance"),

  new SlashCommandBuilder().setName("ticket").setDescription("Create support ticket")
];

const rest = new REST({ version: "10" }).setToken(process.env.TOKEN);

(async () => {
  await rest.put(
    Routes.applicationGuildCommands(process.env.CLIENT_ID, process.env.GUILD_ID),
    { body: commands }
  );
  console.log("âœ… Slash commands registered");
})();

/* =============================
   READY
============================= */

client.once("ready", () => {
  console.log(`ğŸš€ Logged in as ${client.user.tag}`);
});

/* =============================
   LEVELING + AUTOMOD
============================= */

const spamCooldown = new Map();

client.on("messageCreate", async message => {
  if (!message.guild || message.author.bot) return;

  // Anti-Link
  if (message.content.includes("http")) {
    if (!message.member.permissions.has(PermissionsBitField.Flags.ManageMessages)) {
      message.delete().catch(() => {});
      return message.channel.send("ğŸš« Links not allowed")
        .then(msg => setTimeout(() => msg.delete(), 3000));
    }
  }

  // Anti-Spam
  const now = Date.now();
  if (spamCooldown.has(message.author.id)) {
    if (now - spamCooldown.get(message.author.id) < 3000) {
      message.delete().catch(() => {});
      return;
    }
  }
  spamCooldown.set(message.author.id, now);

  // Leveling
  let data = await Level.findOne({
    guildId: message.guild.id,
    userId: message.author.id
  });

  if (!data) {
    data = new Level({
      guildId: message.guild.id,
      userId: message.author.id
    });
  }

  data.xp += 10;

  if (data.xp >= data.level * 100 + 100) {
    data.level += 1;
    message.channel.send(`ğŸ‰ ${message.author} leveled up to ${data.level}`);
  }

  await data.save();
});

/* =============================
   COMMAND HANDLER
============================= */

client.on("interactionCreate", async interaction => {
  if (!interaction.isChatInputCommand()) return;

  const { commandName } = interaction;

  if (commandName === "ping")
    return interaction.reply(`ğŸ“ ${client.ws.ping}ms`);

  if (commandName === "ban") {
    if (!interaction.member.permissions.has(PermissionsBitField.Flags.BanMembers))
      return interaction.reply({ content: "No permission", ephemeral: true });

    const user = interaction.options.getUser("user");
    const member = interaction.guild.members.cache.get(user.id);
    await member.ban();
    return interaction.reply(`ğŸ”¨ Banned ${user.tag}`);
  }

  if (commandName === "kick") {
    if (!interaction.member.permissions.has(PermissionsBitField.Flags.KickMembers))
      return interaction.reply({ content: "No permission", ephemeral: true });

    const user = interaction.options.getUser("user");
    const member = interaction.guild.members.cache.get(user.id);
    await member.kick();
    return interaction.reply(`ğŸ‘¢ Kicked ${user.tag}`);
  }

  if (commandName === "timeout") {
    if (!interaction.member.permissions.has(PermissionsBitField.Flags.ModerateMembers))
      return interaction.reply({ content: "No permission", ephemeral: true });

    const user = interaction.options.getUser("user");
    const minutes = interaction.options.getInteger("minutes");
    const member = interaction.guild.members.cache.get(user.id);

    await member.timeout(minutes * 60000);
    return interaction.reply(`â³ Timed out ${user.tag} for ${minutes} minutes`);
  }

  if (commandName === "warn") {
    const user = interaction.options.getUser("user");
    const reason = interaction.options.getString("reason");

    let data = await Warn.findOne({
      guildId: interaction.guild.id,
      userId: user.id
    });

    if (!data) {
      data = new Warn({
        guildId: interaction.guild.id,
        userId: user.id,
        warnings: []
      });
    }

    data.warnings.push({
      reason,
      moderator: interaction.user.tag
    });

    await data.save();
    return interaction.reply(`âš ï¸ Warned ${user.tag}`);
  }

  if (commandName === "warnings") {
    const user = interaction.options.getUser("user");
    const data = await Warn.findOne({
      guildId: interaction.guild.id,
      userId: user.id
    });

    if (!data || data.warnings.length === 0)
      return interaction.reply("No warnings.");

    return interaction.reply(`ğŸ“‹ ${user.tag} has ${data.warnings.length} warnings.`);
  }

  if (commandName === "work") {
    let data = await Economy.findOne({
      guildId: interaction.guild.id,
      userId: interaction.user.id
    });

    if (!data) {
      data = new Economy({
        guildId: interaction.guild.id,
        userId: interaction.user.id
      });
    }

    const amount = Math.floor(Math.random() * 200) + 50;
    data.balance += amount;
    await data.save();

    return interaction.reply(`ğŸ’° You earned $${amount}`);
  }

  if (commandName === "balance") {
    let data = await Economy.findOne({
      guildId: interaction.guild.id,
      userId: interaction.user.id
    });

    if (!data) data = { balance: 0 };

    return interaction.reply(`ğŸ’³ Balance: $${data.balance}`);
  }

  if (commandName === "ticket") {
    const channel = await interaction.guild.channels.create({
      name: `ticket-${interaction.user.username}`,
      type: ChannelType.GuildText,
      permissionOverwrites: [
        {
          id: interaction.guild.id,
          deny: ["ViewChannel"]
        },
        {
          id: interaction.user.id,
          allow: ["ViewChannel"]
        }
      ]
    });

    return interaction.reply({ content: `ğŸ« Ticket created: ${channel}`, ephemeral: true });
  }
});

client.login(process.env.MTQ1NzQxNzgxMjcwNzYzOTMyNg.GegR9b.W-_zGSZeqfbe2Qp5HqVLHGmLLN_VeBINFJDz5c);
